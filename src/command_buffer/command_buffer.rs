use objc2::{Message, extern_protocol, msg_send, rc::Retained, runtime::ProtocolObject};
use objc2_foundation::{NSError, NSObjectProtocol, NSString};

use crate::{
    MTLCommandBufferHandler, MTLCommandBufferStatus, MTLDrawable, MTLEvent, MTLLogContainer,
};

extern_protocol!(
    /// A serial list of commands for the device to execute.
    ///
    /// Availability: macOS 10.11+, iOS 8.0+
    pub unsafe trait MTLCommandBuffer: NSObjectProtocol {
        /// Append this command buffer to the end of its command queue.
        #[unsafe(method(enqueue))]
        #[unsafe(method_family = none)]
        fn enqueue(&self);

        #[unsafe(method(commit))]
        #[unsafe(method_family = none)]
        fn commit(&self);

        #[unsafe(method(waitUntilCompleted))]
        #[unsafe(method_family = none)]
        fn wait_until_completed(&self);

        #[unsafe(method(error))]
        #[unsafe(method_family = none)]
        fn error(&self) -> Option<Retained<NSError>>;

        #[unsafe(method(status))]
        #[unsafe(method_family = none)]
        fn status(&self) -> MTLCommandBufferStatus;

        /// Logs generated by the command buffer during execution of the GPU commands. Valid after GPU execution is completed.
        #[unsafe(method(logs))]
        #[unsafe(method_family = none)]
        unsafe fn logs(&self) -> Retained<ProtocolObject<dyn MTLLogContainer>>;

        #[unsafe(method(presentDrawable:))]
        #[unsafe(method_family = none)]
        fn present_drawable(&self, drawable: &ProtocolObject<dyn MTLDrawable>);

        /// Encodes a wait for event/value. Only valid when no current encoder is active on the receiver.
        #[unsafe(method(encodeWaitForEvent:value:))]
        #[unsafe(method_family = none)]
        fn encode_wait_for_event_value(&self, event: &ProtocolObject<dyn MTLEvent>, value: u64);

        /// Encodes a signal for event/value. Only valid when no current encoder is active on the receiver.
        #[unsafe(method(encodeSignalEvent:value:))]
        #[unsafe(method_family = none)]
        fn encode_signal_event_value(&self, event: &ProtocolObject<dyn MTLEvent>, value: u64);
    }
);

#[allow(unused)]
pub trait MTLCommandBufferExt: MTLCommandBuffer + Message {
    fn label(&self) -> Option<String>;
    fn set_label(&self, label: Option<&str>);
    /// Adds a block to be called when this command buffer has been scheduled for execution.
    fn add_scheduled_handler(&self, handler: &MTLCommandBufferHandler);
    /// Adds a block to be called when this command buffer has completed execution.
    fn add_completed_handler(&self, handler: &MTLCommandBufferHandler);
}

impl MTLCommandBufferExt for ProtocolObject<dyn MTLCommandBuffer> {
    fn label(&self) -> Option<String> {
        let label: Option<Retained<NSString>> = unsafe { msg_send![self, label] };
        label.map(|s| s.to_string())
    }

    fn set_label(&self, label: Option<&str>) {
        unsafe {
            let _: () = msg_send![self, setLabel: label.map(NSString::from_str).as_deref()];
        }
    }

    fn add_scheduled_handler(&self, handler: &MTLCommandBufferHandler) {
        unsafe {
            let _: () = msg_send![self, addScheduledHandler: &**handler];
        }
    }

    fn add_completed_handler(&self, handler: &MTLCommandBufferHandler) {
        unsafe {
            let _: () = msg_send![self, addCompletedHandler: &**handler];
        }
    }
}
