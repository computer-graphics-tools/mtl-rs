//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use objc2::encode::{Encode, Encoding, RefEncode};

use crate::*;

/// A struct representing a range of a Metal buffer. The offset into the buffer is included in the address.
/// The length is generally optional, which a value of (uint64_t)-1 representing the range from the given address to
/// the end of the buffer. However, providing the length can enable more accurate API validation, especially when
/// sub-allocating ranges of a buffer.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/metal/mtl4bufferrange?language=objc)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct MTL4BufferRange {
    /// Buffer address returned by the gpuAddress property of an MTLBuffer plus any offset into the buffer
    pub buffer_address: MTLGPUAddress,
    /// Length of the region which begins at the given address. If the length is not known, a value of
    /// (uint64_t)-1 represents the range from the given address to the end of the buffer.
    pub length: u64,
}

unsafe impl Encode for MTL4BufferRange {
    const ENCODING: Encoding = Encoding::Struct(
        "MTL4BufferRange",
        &[<MTLGPUAddress>::ENCODING, <u64>::ENCODING],
    );
}

unsafe impl RefEncode for MTL4BufferRange {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl MTL4BufferRange {
    /// Special length value meaning the range extends from `buffer_address` to the end of the buffer.
    pub const WHOLE_BUFFER_LENGTH: u64 = u64::MAX;

    /// Creates a buffer range.
    ///
    /// - `length`: when `None`, uses `WHOLE_BUFFER_LENGTH` (from address to end of buffer).
    #[inline]
    pub fn new(buffer_address: MTLGPUAddress, length: Option<u64>) -> Self {
        Self {
            buffer_address,
            length: length.unwrap_or(Self::WHOLE_BUFFER_LENGTH),
        }
    }

    /// Creates a range that spans from `buffer_address` to the end of the buffer.
    #[inline]
    pub fn whole_buffer(buffer_address: MTLGPUAddress) -> Self {
        Self {
            buffer_address,
            length: Self::WHOLE_BUFFER_LENGTH,
        }
    }

    /// Returns true if this range spans to the end of the buffer.
    #[inline]
    pub fn is_whole_buffer(&self) -> bool {
        self.length == Self::WHOLE_BUFFER_LENGTH
    }
}
